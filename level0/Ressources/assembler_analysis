------MAIN------
Dump of assembler code for function main:
   0x08048ec0 <+0>:     push   ebp
   0x08048ec1 <+1>:     mov    ebp,esp
   0x08048ec3 <+3>:     and    esp,0xfffffff0
   0x08048ec6 <+6>:     sub    esp,0x20
   0x08048ec9 <+9>:     mov    eax,DWORD PTR [ebp+0xc]
   0x08048ecc <+12>:    add    eax,0x4
   0x08048ecf <+15>:    mov    eax,DWORD PTR [eax]
   0x08048ed1 <+17>:    mov    DWORD PTR [esp],eax
   0x08048ed4 <+20>:    call   0x8049710 <atoi>
   0x08048ed9 <+25>:    cmp    eax,0x1a7
   0x08048ede <+30>:    jne    0x8048f58 <main+152>
   0x08048ee0 <+32>:    mov    DWORD PTR [esp],0x80c5348
   0x08048ee7 <+39>:    call   0x8050bf0 <strdup>
   0x08048eec <+44>:    mov    DWORD PTR [esp+0x10],eax
   0x08048ef0 <+48>:    mov    DWORD PTR [esp+0x14],0x0
   0x08048ef8 <+56>:    call   0x8054680 <getegid>
   0x08048efd <+61>:    mov    DWORD PTR [esp+0x1c],eax
   0x08048f01 <+65>:    call   0x8054670 <geteuid>
   0x08048f06 <+70>:    mov    DWORD PTR [esp+0x18],eax
   0x08048f0a <+74>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048f0e <+78>:    mov    DWORD PTR [esp+0x8],eax
   0x08048f12 <+82>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048f16 <+86>:    mov    DWORD PTR [esp+0x4],eax
   0x08048f1a <+90>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048f1e <+94>:    mov    DWORD PTR [esp],eax
   0x08048f21 <+97>:    call   0x8054700 <setresgid>
   0x08048f26 <+102>:   mov    eax,DWORD PTR [esp+0x18]
   0x08048f2a <+106>:   mov    DWORD PTR [esp+0x8],eax
   0x08048f2e <+110>:   mov    eax,DWORD PTR [esp+0x18]
   0x08048f32 <+114>:   mov    DWORD PTR [esp+0x4],eax
   0x08048f36 <+118>:   mov    eax,DWORD PTR [esp+0x18]
   0x08048f3a <+122>:   mov    DWORD PTR [esp],eax
   0x08048f3d <+125>:   call   0x8054690 <setresuid>
   0x08048f42 <+130>:   lea    eax,[esp+0x10]
   0x08048f46 <+134>:   mov    DWORD PTR [esp+0x4],eax
   0x08048f4a <+138>:   mov    DWORD PTR [esp],0x80c5348
   0x08048f51 <+145>:   call   0x8054640 <execv>
   0x08048f56 <+150>:   jmp    0x8048f80 <main+192>
   0x08048f58 <+152>:   mov    eax,ds:0x80ee170
   0x08048f5d <+157>:   mov    edx,eax
   0x08048f5f <+159>:   mov    eax,0x80c5350
   0x08048f64 <+164>:   mov    DWORD PTR [esp+0xc],edx
   0x08048f68 <+168>:   mov    DWORD PTR [esp+0x8],0x5
   0x08048f70 <+176>:   mov    DWORD PTR [esp+0x4],0x1
   0x08048f78 <+184>:   mov    DWORD PTR [esp],eax
   0x08048f7b <+187>:   call   0x804a230 <fwrite>
   0x08048f80 <+192>:   mov    eax,0x0
   0x08048f85 <+197>:   leave
   0x08048f86 <+198>:   ret
End of assembler dump.

------ОБЪЯСНЕНИЕ------

   0x08048ec0 <+0>:     push   ebp
   0x08048ec1 <+1>:     mov    ebp,esp

<+0> - Пуш EBP, чтобы сохранить начало stackframe предыдущей функции.
<+1>: Сохраняет содержимое ESP (указатель стека), где содержится адрес верхней части стека, в EBP.

   0x08048ec3 <+3>:     and    esp,0xfffffff0
   0x08048ec6 <+6>:     sub    esp,0x20

<+3>: Выравнивание стека на 16 байт не требуется, так как нет инструкций SIMD
<+6>: 32 байта выделяются основной функции для ее локальных переменных.

   0x08048ec9 <+9>:     mov    eax,DWORD PTR [ebp+0xc]
   0x08048ecc <+12>:    add    eax,0x4
   0x08048ecf <+15>:    mov    eax,DWORD PTR [eax]

<+9> - <+15> : Храние значение argv +1 (argv[1]) в EAX, поэтому EAX теперь является указателем.

   0x08048ed1 <+17>:    mov    DWORD PTR [esp],eax
   0x08048ed4 <+20>:    call   0x8049710 <atoi>
   0x08048ed9 <+25>:    cmp    eax,0x1a7
   0x08048ede <+30>:    jne    0x8048f58 <main+152>

<+17>: Храние EAX (argv[1]) по адресу ESP (в верхней части стека).
<+20>: Вызов atoi(), который примет в качестве аргумента значение, хранящееся по адресу ESP (atoi(argv[1])).
<+25>: Затем сравнивание значение возврата atoi() с 0x1a7 (423).
<+<+30>: Сравнение JNE. Если результат atoi() не равен 0x1a7, перейдите по адресу 0x8048f58 (main+152), в противном случае продолжайте.

   0x08048ee0 <+32>:    mov    DWORD PTR [esp],0x80c5348
   0x08048ee7 <+39>:    call   0x8050bf0 <strdup>
   0x08048eec <+44>:    mov    DWORD PTR [esp+0x10],eax

<+32>: Сохранение 0x80c5348 (адрес строки "/bin/sh") в адресе esp.
<+39>: Вызов strdup(), который примет в качестве аргумента значение, хранящееся по адресу esp (указатель на строку "/bin/sh").
<+44>: Сохранение функцию возврата по адресу esp+16.

   0x08048ef0 <+48>:    mov    DWORD PTR [esp+0x14],0x0
   0x08048ef8 <+56>:    call   0x8054680 <getegid>
   0x08048efd <+61>:    mov    DWORD PTR [esp+0x1c],eax
   0x08048f01 <+65>:    call   0x8054670 <geteuid>
   0x08048f06 <+70>:    mov    DWORD PTR [esp+0x18],eax

<+48>: Это будет нулевой указатель для закрытия вкладки указателя, который будет использоваться в качестве второго аргумента для функции execv().
<+56> - <+70> : Вызывает getegid(), затем geteuid(). Сохранение их значения соответственно по адресам esp+0x1c и esp+0x18.

   0x08048f0a <+74>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048f0e <+78>:    mov    DWORD PTR [esp+0x8],eax
   0x08048f12 <+82>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048f16 <+86>:    mov    DWORD PTR [esp+0x4],eax
   0x08048f1a <+90>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048f1e <+94>:    mov    DWORD PTR [esp],eax
   0x08048f21 <+97>:    call   0x8054700 <setresgid>

<+74> - <+94> : Назначение аргументов для функции setresgid().
<+97>: Вызов функции setresgid() со значениями по адресам esp, esp+4 и esp+8 в качестве аргументов (setresgid(gid, gid, gid)).

   0x08048f26 <+102>:   mov    eax,DWORD PTR [esp+0x18]
   0x08048f2a <+106>:   mov    DWORD PTR [esp+0x8],eax
   0x08048f2e <+110>:   mov    eax,DWORD PTR [esp+0x18]
   0x08048f32 <+114>:   mov    DWORD PTR [esp+0x4],eax
   0x08048f36 <+118>:   mov    eax,DWORD PTR [esp+0x18]
   0x08048f3a <+122>:   mov    DWORD PTR [esp],eax
   0x08048f3d <+125>:   call   0x8054690 <setresuid>

<+102> - <+122> : Назначение аргументов для функции setresuid().
<+97>: Вызов функции setresuid() со значениями по адресам esp, esp+4 и esp+8 в качестве аргументов (setresuid(uid, uid, uid)).

   0x08048f42 <+130>:   lea    eax,[esp+0x10]
   0x08048f46 <+134>:   mov    DWORD PTR [esp+0x4],eax
   0x08048f4a <+138>:   mov    DWORD PTR [esp],0x80c5348
   0x08048f51 <+145>:   call   0x8054640 <execv>

<+130>: EAX указывает на esp+0x10.
<+134> - <+138> : Задаёт аргументы для функции execv().
<+145>: Вызов функции execv() со значениями по адресам esp и esp+4 в качестве аргументов (execve("/bin/sh", [esp+0x10, esp+0x14])).

   0x08048f56 <+150>:   jmp    0x8048f80 <main+192>

<+150>: Окончательный переход по адресу 0x8048f80 (основной+192).

   0x08048f58 <+152>:   mov    eax,ds:0x80ee170
   0x08048f5d <+157>:   mov    edx,eax
   0x08048f5f <+159>:   mov    eax,0x80c5350
   0x08048f64 <+164>:   mov    DWORD PTR [esp+0xc],edx
   0x08048f68 <+168>:   mov    DWORD PTR [esp+0x8],0x5
   0x08048f70 <+176>:   mov    DWORD PTR [esp+0x4],0x1
   0x08048f78 <+184>:   mov    DWORD PTR [esp],eax
   0x08048f7b <+187>:   call   0x804a230 <fwrite>

<+152>: Запомните, это адрес, указанный инструкцией JNE в строке <+30>. Обозначение "ds:[0x80ee170]" означает, что мы достигаем смещения от адреса в "DS" (регистр сегмента данных), поэтому инструкция перемещает двойное слово (32-разрядное значение) из адреса "ds:[0x80ee170]" в регистр eax (eax = stderr).
<+<+157>: Сохраняем значение eax inc edx.
<+159>: Затем сохраняем значение 0x80c5350 в eax (eax = "Нет!\n").
<+164> - <+184> : Задаём аргументы для функции fwrite().
<+187>: Вызов функции fwrite() со значениями по адресам от esp до esp+12 в качестве аргументов (fwrite(esp, esp+4, esp+8, esp+12)).

   0x08048f80 <+192>:   mov    eax,0x0
   0x08048f85 <+197>:   leave
   0x08048f86 <+198>:   ret

<+192> - <+198> : Эти три строки позволяют нам определить состояние регистров перед выполнением функции. В других терминах мы выходим из функции main(), выполняя эквивалент return(0) в C.
