-------ФУНКЦИИ В БИНАРНОМ ФАЙЛЕ-------

(gdb) info functions
All defined functions:

Non-debugging symbols:
0x080482f8  _init
0x08048340  printf@plt
0x08048350  fgets@plt
0x08048360  system@plt
0x08048370  __gmon_start__@plt
0x08048380  __libc_start_main@plt
0x08048390  _start
0x080483c0  __do_global_dtors_aux
0x08048420  frame_dummy
0x08048444  p
0x08048457  n
0x080484a7  main
0x080484c0  __libc_csu_init
0x08048530  __libc_csu_fini
0x08048532  __i686.get_pc_thunk.bx
0x08048540  __do_global_ctors_aux
0x0804856c  _fini

------MAIN------

Dump of assembler code for function main:
   0x080484a7 <+0>:     push   ebp
   0x080484a8 <+1>:     mov    ebp,esp
   0x080484aa <+3>:     and    esp,0xfffffff0
   0x080484ad <+6>:     call   0x8048457 <n>
   0x080484b2 <+11>:    leave
   0x080484b3 <+12>:    ret    
End of assembler dump.

Очень похоже на предыдущий уровень, поэтому я не буду останавливаться на объяснениях.
<+0> - <+12> : Вызовите n() в 0x8048457, затем закройте функцию main().

-------ОБЪЯСНЕНИЕ ФУНКЦИИ n()------

Dump of assembler code for function n:
   0x08048457 <+0>:     push   ebp
   0x08048458 <+1>:     mov    ebp,esp
   0x0804845a <+3>:     sub    esp,0x218
   0x08048460 <+9>:     mov    eax,ds:0x8049804
   0x08048465 <+14>:    mov    DWORD PTR [esp+0x8],eax
   0x08048469 <+18>:    mov    DWORD PTR [esp+0x4],0x200
   0x08048471 <+26>:    lea    eax,[ebp-0x208]
   0x08048477 <+32>:    mov    DWORD PTR [esp],eax
   0x0804847a <+35>:    call   0x8048350 <fgets@plt>
   0x0804847f <+40>:    lea    eax,[ebp-0x208]
   0x08048485 <+46>:    mov    DWORD PTR [esp],eax
   0x08048488 <+49>:    call   0x8048444 <p>
   0x0804848d <+54>:    mov    eax,ds:0x8049810
   0x08048492 <+59>:    cmp    eax,0x1025544
   0x08048497 <+64>:    jne    0x80484a5 <n+78>
   0x08048499 <+66>:    mov    DWORD PTR [esp],0x8048590
   0x080484a0 <+73>:    call   0x8048360 <system@plt>
   0x080484a5 <+78>:    leave
   0x080484a6 <+79>:    ret
End of assembler dump.

--------ОБЪЯСНЕНИЕ--------

Опять же, очень похоже на предыдущий уровень до *n+49.

   0x0804847f <+40>:    lea    eax,[ebp-0x208]
   0x08048485 <+46>:    mov    DWORD PTR [esp],eax
   0x08048488 <+49>:    call   0x8048444 <p>

<+40> - <+46> : Загрузите эффективный адрес ebp-0x208 в eax, чтобы eax теперь указывал на ebp-0x208. Затем MOV  переместите его в esp.
<+49>: Вызовите функцию p() со значением по адресу esp в качестве аргумента (p(buffer)).

   0x0804848d <+54>:    mov    eax,ds:0x8049810
   0x08048492 <+59>:    cmp    eax,0x1025544
   0x08048497 <+64>:    jne    0x80484a5 <n+78>

<+54> - <+64> : JNE сравнение. Если значение глобальной переменной ("m"), хранящейся по адресу 0x8049810, не равно 0x1025544 (16930116), перейдите по адресу 0x80484a5 (n+78), в противном случае продолжайте.

   0x08048499 <+66>:    mov    DWORD PTR [esp],0x8048590
   0x080484a0 <+73>:    call   0x8048360 <system@plt>

<+66>: Задайте аргумент для функции system().
<+73>: Вызов функции system() со значением по адресу esp в качестве аргумента (system("/bin/sh")).

   0x080484a5 <+78>:    leave
   0x080484a6 <+79>:    ret

<+78> - <+79> : Эти две строки позволяют нам определить состояние регистров перед выполнением функции. В других терминах мы выходим из функции main().

-------ФУНКЦИЯ Р()-------

Dump of assembler code for function p:
   0x08048444 <+0>:     push   ebp
   0x08048445 <+1>:     mov    ebp,esp
   0x08048447 <+3>:     sub    esp,0x18
   0x0804844a <+6>:     mov    eax,DWORD PTR [ebp+0x8]
   0x0804844d <+9>:     mov    DWORD PTR [esp],eax
   0x08048450 <+12>:    call   0x8048340 <printf@plt>
   0x08048455 <+17>:    leave
   0x08048456 <+18>:    ret
End of assembler dump.

<+0> - <+18> : Аналогично main с отличиями в том, что функция выделяет 24 байта для своих локальных переменных. И вызовите функцию printf() со значением по адресу esp в качестве аргумента (printf(str)) перед уходом и возвращением.


