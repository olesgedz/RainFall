-------ФУНКЦИИ В БИНАРНОМ ФАЙЛЕ------

(gdb) info functions
All defined functions:

Non-debugging symbols:
0x08048344  _init
0x08048390  printf@plt
0x080483a0  fgets@plt
0x080483b0  fwrite@plt
0x080483c0  system@plt
0x080483d0  __gmon_start__@plt
0x080483e0  __libc_start_main@plt
0x080483f0  _start
0x08048420  __do_global_dtors_aux
0x08048480  frame_dummy
0x080484a4  v
0x0804851a  main
0x08048530  __libc_csu_init
0x080485a0  __libc_csu_fini
0x080485a2  __i686.get_pc_thunk.bx
0x080485b0  __do_global_ctors_aux
0x080485dc  _fini

-------MAIN-------

Dump of assembler code for function main:
   0x0804851a <+0>:     push   ebp
   0x0804851b <+1>:     mov    ebp,esp
   0x0804851d <+3>:     and    esp,0xfffffff0
   0x08048520 <+6>:     call   0x80484d4 <p>
   0x08048525 <+11>:    leave
   0x08048526 <+12>:    ret
End of assembler dump.


-------ОБЪЯСНЕНИЕ--------

   0x0804851a <+0>:     push   ebp
   0x0804851b <+1>:     mov    ebp,esp

<+0>: Пуш ebp, чтобы сохранить начало кадра стека предыдущей функции.
<+1>: Сохранение содержимое ESP (указатель стека), в котором содержится адрес вершины стека, в EBP.

   0x0804851d <+3>:     and    esp,0xfffffff0
   0x08048520 <+6>:     call   0x80484d4 <p>

<+3>: Выравнивание стека по 16 байтам не требуется, поскольку нет инструкций SIMD.
<+6>: Вызов функции р(), мы посмотрим, как должен выглядеть стек в начале объяснений p().

   0x08048525 <+11>:    leave
   0x08048526 <+12>:    ret

<+11> - <+12> : Эти две строки позволяют нам определить состояние регистров перед выполнением функции. В других терминах мы выходим из функции main(). Конечно, мы выполним эти инструкции, как только покинем функцию p().

------ФУНКЦИЯ V()------

Dump of assembler code for function v:
   0x080484a4 <+0>:     push   ebp
   0x080484a5 <+1>:     mov    ebp,esp
   0x080484a7 <+3>:     sub    esp,0x218
   0x080484ad <+9>:     mov    eax,ds:0x8049860
   0x080484b2 <+14>:    mov    DWORD PTR [esp+0x8],eax
   0x080484b6 <+18>:    mov    DWORD PTR [esp+0x4],0x200
   0x080484be <+26>:    lea    eax,[ebp-0x208]
   0x080484c4 <+32>:    mov    DWORD PTR [esp],eax
   0x080484c7 <+35>:    call   0x80483a0 <fgets@plt>
   0x080484cc <+40>:    lea    eax,[ebp-0x208]
   0x080484d2 <+46>:    mov    DWORD PTR [esp],eax
   0x080484d5 <+49>:    call   0x8048390 <printf@plt>
   0x080484da <+54>:    mov    eax,ds:0x804988c
   0x080484df <+59>:    cmp    eax,0x40
   0x080484e2 <+62>:    jne    0x8048518 <v+116>
   0x080484e4 <+64>:    mov    eax,ds:0x8049880
   0x080484e9 <+69>:    mov    edx,eax
   0x080484eb <+71>:    mov    eax,0x8048600
   0x080484f0 <+76>:    mov    DWORD PTR [esp+0xc],edx
   0x080484f4 <+80>:    mov    DWORD PTR [esp+0x8],0xc
   0x080484fc <+88>:    mov    DWORD PTR [esp+0x4],0x1
   0x08048504 <+96>:    mov    DWORD PTR [esp],eax
   0x08048507 <+99>:    call   0x80483b0 <fwrite@plt>
   0x0804850c <+104>:   mov    DWORD PTR [esp],0x804860d
   0x08048513 <+111>:   call   0x80483c0 <system@plt>
   0x08048518 <+116>:   leave
   0x08048519 <+117>:   ret
End of assembler dump.

-------ОБЪЯСНЕНИЕ-------

   0x080484a4 <+0>:     push   ebp
   0x080484a5 <+1>:     mov    ebp,esp

<+0>: Пуш ebp, чтобы сохранить начало кадра стека предыдущей функции.
<+1>: Хранит содержимое ESP (указатель стека), в котором содержится адрес верхней части стека, в EBP.

   0x080484a7 <+3>:     sub    esp,0x218

<+3>: 536 байт выделено основной функции для ее локальных переменных.

   0x080484ad <+9>:     mov    eax,ds:0x8049860
   0x080484b2 <+14>:    mov    DWORD PTR [esp+0x8],eax
   0x080484b6 <+18>:    mov    DWORD PTR [esp+0x4],0x200
   0x080484be <+26>:    lea    eax,[ebp-0x208]
   0x080484c4 <+32>:    mov    DWORD PTR [esp],eax
   0x080484c7 <+35>:    call   0x80483a0 <fgets@plt>

<+9>: обозначение "ds:[0x8049860]" означает, что мы достигаем смещения от адреса в "DS" (регистр сегмента данных), поэтому инструкция перемещает двойное слово (32-разрядное значение) из адреса "ds:[0x8049860]" в регистр eax (eax = stdin).
<+14> - <+32> : Задаёт аргументы для функции fgets() и загрузите эффективный адрес ebp-0x208 в eax, поэтому eax теперь указывает на ebp-0x208 (идеально, функции fgets() нужен указатель в качестве первого аргумента).
<+35>: Вызов функции fgets() со значениями по адресам esp, esp+4 и esp+8 в качестве аргумента (fgets(eax, 512, stdin)).

   0x080484cc <+40>:    lea    eax,[ebp-0x208]
   0x080484d2 <+46>:    mov    DWORD PTR [esp],eax
   0x080484d5 <+49>:    call   0x8048390 <printf@plt>

<+40> - <+49> : Вывод указателя, переданного в качестве первого аргумента в fgets() (printf(eax)).

   0x080484da <+54>:    mov    eax,ds:0x804988c
   0x080484df <+59>:    cmp    eax,0x40
   0x080484e2 <+62>:    jne    0x8048518 <v+116>

<+54> - <+62> : JNE сравнение. Если значение глобальной переменной ("m"), хранящейся по адресу 0x804988c, не равно 0x40 (64), перейдите по адресу 0x8048518 (v+116), в противном случае продолжайте.

   0x080484e4 <+64>:    mov    eax,ds:0x8049880
   0x080484e9 <+69>:    mov    edx,eax
   0x080484eb <+71>:    mov    eax,0x8048600
   0x080484f0 <+76>:    mov    DWORD PTR [esp+0xc],edx
   0x080484f4 <+80>:    mov    DWORD PTR [esp+0x8],0xc
   0x080484fc <+88>:    mov    DWORD PTR [esp+0x4],0x1
   0x08048504 <+96>:    mov    DWORD PTR [esp],eax
   0x08048507 <+99>:    call   0x80483b0 <fwrite@plt>

<+64>: "ds:[0x8049880]" обозначение означает, что мы достигаем смещения от адреса в "DS" (регистр сегмента данных), поэтому инструкция перемещает двойное слово (32-разрядное значение) из адреса "ds:[0x8049880]" в регистр eax (eax = stdout).
<+69>: Сохранение значения eax в edx.
<+71>: Затем сохранение значений по адресу 0x8048600 в eax (eax= "Подождите, что?!\n").
<+76> - <+96> : Задайте аргументы для функции fwrite().
<+99>: Вызов функции fwrite() со значениями по адресам от esp до esp+12 в качестве аргументов (fwrite(esp, esp+4, esp+8, esp+12)).

   0x0804850c <+104>:   mov    DWORD PTR [esp],0x804860d
   0x08048513 <+111>:   call   0x80483c0 <system@plt>

<+104>: Установка аргумента для функции system().
<+111>: Вызов функции system() со значением по адресу esp в качестве аргумента (system("/bin/sh")).

   0x08048518 <+116>:   leave
   0x08048519 <+117>:   ret

<+116> - <+117> : Эти две строки позволяют нам определить состояние регистров перед выполнением функции. В других терминах мы выходим из функции main().


