-------ФУНКЦИИ В БИНАРНОМ ФАЙЛЕ-------

(gdb) info functions
All defined functions:

Non-debugging symbols:
0x0804836c  _init
0x080483b0  printf@plt
0x080483c0  fgets@plt
0x080483d0  time@plt
0x080483e0  strcpy@plt
0x080483f0  malloc@plt
0x08048400  puts@plt
0x08048410  __gmon_start__@plt
0x08048420  __libc_start_main@plt
0x08048430  fopen@plt
0x08048440  _start
0x08048470  __do_global_dtors_aux
0x080484d0  frame_dummy
0x080484f4  m
0x08048521  main
0x08048610  __libc_csu_init
0x08048680  __libc_csu_fini
0x08048682  __i686.get_pc_thunk.bx
0x08048690  __do_global_ctors_aux
0x080486bc  _fini

-------MAIN-------

Dump of assembler code for function main:
   0x08048521 <+0>:     push   ebp
   0x08048522 <+1>:     mov    ebp,esp
   0x08048524 <+3>:     and    esp,0xfffffff0
   0x08048527 <+6>:     sub    esp,0x20
   0x0804852a <+9>:     mov    DWORD PTR [esp],0x8
   0x08048531 <+16>:    call   0x80483f0 <malloc@plt>
   0x08048536 <+21>:    mov    DWORD PTR [esp+0x1c],eax
   0x0804853a <+25>:    mov    eax,DWORD PTR [esp+0x1c]
   0x0804853e <+29>:    mov    DWORD PTR [eax],0x1
   0x08048544 <+35>:    mov    DWORD PTR [esp],0x8
   0x0804854b <+42>:    call   0x80483f0 <malloc@plt>
   0x08048550 <+47>:    mov    edx,eax
   0x08048552 <+49>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048556 <+53>:    mov    DWORD PTR [eax+0x4],edx
   0x08048559 <+56>:    mov    DWORD PTR [esp],0x8
   0x08048560 <+63>:    call   0x80483f0 <malloc@plt>
   0x08048565 <+68>:    mov    DWORD PTR [esp+0x18],eax
   0x08048569 <+72>:    mov    eax,DWORD PTR [esp+0x18]
   0x0804856d <+76>:    mov    DWORD PTR [eax],0x2
   0x08048573 <+82>:    mov    DWORD PTR [esp],0x8
   0x0804857a <+89>:    call   0x80483f0 <malloc@plt>
   0x0804857f <+94>:    mov    edx,eax
   0x08048581 <+96>:    mov    eax,DWORD PTR [esp+0x18]
   0x08048585 <+100>:   mov    DWORD PTR [eax+0x4],edx
   0x08048588 <+103>:   mov    eax,DWORD PTR [ebp+0xc]
   0x0804858b <+106>:   add    eax,0x4
   0x0804858e <+109>:   mov    eax,DWORD PTR [eax]
   0x08048590 <+111>:   mov    edx,eax
   0x08048592 <+113>:   mov    eax,DWORD PTR [esp+0x1c]
   0x08048596 <+117>:   mov    eax,DWORD PTR [eax+0x4]
   0x08048599 <+120>:   mov    DWORD PTR [esp+0x4],edx
   0x0804859d <+124>:   mov    DWORD PTR [esp],eax
   0x080485a0 <+127>:   call   0x80483e0 <strcpy@plt>
   0x080485a5 <+132>:   mov    eax,DWORD PTR [ebp+0xc]
   0x080485a8 <+135>:   add    eax,0x8
   0x080485ab <+138>:   mov    eax,DWORD PTR [eax]
   0x080485ad <+140>:   mov    edx,eax
   0x080485af <+142>:   mov    eax,DWORD PTR [esp+0x18]
   0x080485b3 <+146>:   mov    eax,DWORD PTR [eax+0x4]
   0x080485b6 <+149>:   mov    DWORD PTR [esp+0x4],edx
   0x080485ba <+153>:   mov    DWORD PTR [esp],eax
   0x080485bd <+156>:   call   0x80483e0 <strcpy@plt>
   0x080485c2 <+161>:   mov    edx,0x80486e9
   0x080485c7 <+166>:   mov    eax,0x80486eb
   0x080485cc <+171>:   mov    DWORD PTR [esp+0x4],edx
   0x080485d0 <+175>:   mov    DWORD PTR [esp],eax
   0x080485d3 <+178>:   call   0x8048430 <fopen@plt>
   0x080485d8 <+183>:   mov    DWORD PTR [esp+0x8],eax
   0x080485dc <+187>:   mov    DWORD PTR [esp+0x4],0x44
   0x080485e4 <+195>:   mov    DWORD PTR [esp],0x8049960
   0x080485eb <+202>:   call   0x80483c0 <fgets@plt>
   0x080485f0 <+207>:   mov    DWORD PTR [esp],0x8048703
   0x080485f7 <+214>:   call   0x8048400 <puts@plt>
   0x080485fc <+219>:   mov    eax,0x0
   0x08048601 <+224>:   leave
   0x08048602 <+225>:   ret
End of assembler dump.

-------ОБЪЯСНЕНИЕ--------

   0x08048521 <+0>:     push   ebp
   0x08048522 <+1>:     mov    ebp,esp

<+0>: Пуш ebp, чтобы сохранить начало кадра стека предыдущей функции.
<+1>: Хранит содержимое ESP (указатель стека), в котором содержится адрес верхней части стека, в EBP.

   0x08048524 <+3>:     and    esp,0xfffffff0
   0x08048527 <+6>:     sub    esp,0x20

<+3>: Выравнивание стека по 16 байтам не требуется, поскольку нет инструкций SIMD.
<+6>: 32 байта выделяются основной функции для ее локальных переменных.

   0x0804852a <+9>:     mov    DWORD PTR [esp],0x8
   0x08048531 <+16>:    call   0x80483f0 <malloc@plt>
   0x08048536 <+21>:    mov    DWORD PTR [esp+0x1c],eax

<+9> - <+21> : Вызов malloc() со значением по адресу esp в качестве аргумента (malloc(8)), затем сохраните возвращаемое значение в esp+0x1c.

   0x0804853a <+25>:    mov    eax,DWORD PTR [esp+0x1c]
   0x0804853e <+29>:    mov    DWORD PTR [eax],0x1
   0x08048544 <+35>:    mov    DWORD PTR [esp],0x8
   0x0804854b <+42>:    call   0x80483f0 <malloc@plt>
   0x08048550 <+47>:    mov    edx,eax
   0x08048552 <+49>:    mov    eax,DWORD PTR [esp+0x1c]
   0x08048556 <+53>:    mov    DWORD PTR [eax+0x4],edx

<+25> - <+29> : Установка eax, указывающего на область первого malloc(), затем установите первый случай malloc() в 0x1 (a = malloc(8); a[0] = 0x1).
<+35> - <+42> : Второй вызов malloc(8).
<+47> - <+53> : Снова установка eax, указывающего на область первого malloc(), затем установите второй случай malloc() в edx (a = malloc(8); a[1] = malloc(8)).

   0x08048559 <+56>:    mov    DWORD PTR [esp],0x8
   0x08048560 <+63>:    call   0x80483f0 <malloc@plt>
   0x08048565 <+68>:    mov    DWORD PTR [esp+0x18],eax

<+56> - <+68> : Вызов malloc() со значением по адресу esp в качестве аргумента (malloc(8)), затем сохраните возвращаемое значение в esp+0x18.

   0x08048569 <+72>:    mov    eax,DWORD PTR [esp+0x18]
   0x0804856d <+76>:    mov    DWORD PTR [eax],0x2
   0x08048573 <+82>:    mov    DWORD PTR [esp],0x8
   0x0804857a <+89>:    call   0x80483f0 <malloc@plt>
   0x0804857f <+94>:    mov    edx,eax
   0x08048581 <+96>:    mov    eax,DWORD PTR [esp+0x18]
   0x08048585 <+100>:   mov    DWORD PTR [eax+0x4],edx

<+72> - <+76> : Установка eax, указывающего на область третьего malloc(), затем установите первый случай malloc() равным 0x2 (b = malloc(8); b[0] = 0x2).
<+82> - <+89> : Четвертый вызов malloc(8).
<+47> - <+53> : Снова установка eax, указывающего на область третьего malloc(), затем установите второй случай malloc() в edx (b = malloc(8); b[1] = malloc(8)).

   0x08048588 <+103>:   mov    eax,DWORD PTR [ebp+0xc]
   0x0804858b <+106>:   add    eax,0x4
   0x0804858e <+109>:   mov    eax,DWORD PTR [eax]
   0x08048590 <+111>:   mov    edx,eax

<+103> - <+111> : Хранить непосредственно значение argv[1] в eax, поэтому eax теперь является указателем на первый аргумент функции main(). Затем сохраните значение eax в edx.

   0x08048592 <+113>:   mov    eax,DWORD PTR [esp+0x1c]
   0x08048596 <+117>:   mov    eax,DWORD PTR [eax+0x4]
   0x08048599 <+120>:   mov    DWORD PTR [esp+0x4],edx
   0x0804859d <+124>:   mov    DWORD PTR [esp],eax
   0x080485a0 <+127>:   call   0x80483e0 <strcpy@plt>

<+113> - <+117> : eax теперь указывает на второй случай области первого malloc() (eax = a[1]).
<+120> - <+124> : Установка аргументов для функции strcpy().
<+127>: Вызов strcpy() со значениями по адресам esp и esp+4 в качестве аргументов (strcpy(a[1], argv[1])).

   0x080485a5 <+132>:   mov    eax,DWORD PTR [ebp+0xc]
   0x080485a8 <+135>:   add    eax,0x8
   0x080485ab <+138>:   mov    eax,DWORD PTR [eax]
   0x080485ad <+140>:   mov    edx,eax

<+132> - <+140> : Хранение непосредственно значения argv[2] в eax, поэтому eax теперь является указателем на второй аргумент функции main(). Затем сохраните значение eax в edx.

   0x080485af <+142>:   mov    eax,DWORD PTR [esp+0x18]
   0x080485b3 <+146>:   mov    eax,DWORD PTR [eax+0x4]
   0x080485b6 <+149>:   mov    DWORD PTR [esp+0x4],edx
   0x080485ba <+153>:   mov    DWORD PTR [esp],eax
   0x080485bd <+156>:   call   0x80483e0 <strcpy@plt>

<+142> - <+146> : eax теперь указывает на второй случай области третьего malloc() (eax = b[1]).
<+149> - <+153> : Установка аргументов для функции strcpy().
<+156>: Вызов strcpy() со значениями по адресам esp и esp+4 в качестве аргументов (strcpy(b[1], argv[2])).

   0x080485c2 <+161>:   mov    edx,0x80486e9
   0x080485c7 <+166>:   mov    eax,0x80486eb
   0x080485cc <+171>:   mov    DWORD PTR [esp+0x4],edx
   0x080485d0 <+175>:   mov    DWORD PTR [esp],eax
   0x080485d3 <+178>:   call   0x8048430 <fopen@plt>

<+161> - <+175> : Установка аргументов для функции fopen().
<+178>: Вызов fopen() со значениями по адресам esp и esp+4 в качестве аргументов (fopen(esp, esp+4)).

   0x080485d8 <+183>:   mov    DWORD PTR [esp+0x8],eax
   0x080485dc <+187>:   mov    DWORD PTR [esp+0x4],0x44
   0x080485e4 <+195>:   mov    DWORD PTR [esp],0x8049960
   0x080485eb <+202>:   call   0x80483c0 <fgets@plt>

<+183> - <+195> : Установка аргументов для функции fgets().
<+202>: Вызов fgets() со значениями по адресам esp, esp+4 и esp+8 в качестве аргументов (fgets(esp, esp+4, esp+8)).

   0x080485f0 <+207>:   mov    DWORD PTR [esp],0x8048703
   0x080485f7 <+214>:   call   0x8048400 <puts@plt>

<+207>: Установка аргумента для функции puts().
<+214>: Вызов puts() со значением по адресу esp в качестве аргумента (puts("~~")).

   0x080485fc <+219>:   mov    eax,0x0
   0x08048601 <+224>:   leave
   0x08048602 <+225>:   ret

<+219> - <+225> : Эти три строки позволяют нам определить состояние регистров перед выполнением функции. В других терминах мы выходим из функции main(), выполняя эквивалент return(0) в C.

--------ФУНКЦИЯ m()-------

Dump of assembler code for function m:
   0x080484f4 <+0>:     push   ebp
   0x080484f5 <+1>:     mov    ebp,esp
   0x080484f7 <+3>:     sub    esp,0x18
   0x080484fa <+6>:     mov    DWORD PTR [esp],0x0
   0x08048501 <+13>:    call   0x80483d0 <time@plt>
   0x08048506 <+18>:    mov    edx,0x80486e0
   0x0804850b <+23>:    mov    DWORD PTR [esp+0x8],eax
   0x0804850f <+27>:    mov    DWORD PTR [esp+0x4],0x8049960
   0x08048517 <+35>:    mov    DWORD PTR [esp],edx
   0x0804851a <+38>:    call   0x80483b0 <printf@plt>
   0x0804851f <+43>:    leave
   0x08048520 <+44>:    ret
End of assembler dump.

--------ОБЪЯСНЕНИЕ--------

   0x080484f4 <+0>:     push   ebp
   0x080484f5 <+1>:     mov    ebp,esp

<+0>:  Пуш ebp, чтобы сохранить начало кадра стека предыдущей функции.
<+1>: Сохраняет содержимое ESP (указатель стека), в котором содержится адрес вершины стека, в EBP.

   0x080484f7 <+3>:     sub    esp,0x18

<+3>: Основной функции выделено 24 байта для ее локальных переменных.

   0x080484fa <+6>:     mov    DWORD PTR [esp],0x0
   0x08048501 <+13>:    call   0x80483d0 <time@plt>

<+6> - <+13> : Вызов функции time() со значением по адресу esp в качестве аргумента (время(0)).

   0x08048506 <+18>:    mov    edx,0x80486e0
   0x0804850b <+23>:    mov    DWORD PTR [esp+0x8],eax
   0x0804850f <+27>:    mov    DWORD PTR [esp+0x4],0x8049960
   0x08048517 <+35>:    mov    DWORD PTR [esp],edx
   0x0804851a <+38>:    call   0x80483b0 <printf@plt>

<+18>: Сохранение адреса 0x80486e0 в формате edx (edx ~= "%s -%d\n").
<+27>: Сохранение адреса глобальной переменной c по адресу esp+4.
<+18> - <+38> : Вызов функции printf() со значениями по адресам от esp до esp+8 в качестве аргументов (printf("%s - %d\n", global_c, время(0))).

   0x0804851f <+43>:    leave
   0x08048520 <+44>:    ret

<+43> - <+44> : Эти две строки позволяют нам определить состояние регистров перед выполнением функции. В других терминах мы выходим из функции main().
