-------ФУНКЦИИ В БИНАРНОМ ФАЙЛЕ------

(gdb) info functions
All defined functions:

Non-debugging symbols:
0x08048358  _init
0x080483a0  printf@plt
0x080483b0  fflush@plt
0x080483c0  gets@plt
0x080483d0  _exit@plt
0x080483e0  strdup@plt
0x080483f0  puts@plt
0x08048400  __gmon_start__@plt
0x08048410  __libc_start_main@plt
0x08048420  _start
0x08048450  __do_global_dtors_aux
0x080484b0  frame_dummy
0x080484d4  p
0x0804853f  main
0x08048550  __libc_csu_init
0x080485c0  __libc_csu_fini
0x080485c2  __i686.get_pc_thunk.bx
0x080485d0  __do_global_ctors_aux
0x080485fc  _fini

-------MAIN-------

Dump of assembler code for function main:
   0x0804853f <+0>:     push   ebp
   0x08048540 <+1>:     mov    ebp,esp
   0x08048542 <+3>:     and    esp,0xfffffff0
   0x08048545 <+6>:     call   0x80484d4 <p>
   0x0804854a <+11>:    leave
   0x0804854b <+12>:    ret
End of assembler dump.

------ОБЪЯСНЕНИЕ------

   0x0804853f <+0>:     push   ebp
   0x08048540 <+1>:     mov    ebp,esp

<+0>: Пуш ebp, чтобы сохранить начало кадра стека предыдущей функции.
<+1>: Сохраняет содержимое ESP (указатель стека), в котором содержится адрес вершины стека, в EBP.

   0x08048542 <+3>:     and    esp,0xfffffff0
   0x08048545 <+6>:     call   0x80484d4 <p>

<+3>: Выравнивание стека по 16 байтам не требуется, поскольку нет инструкций SIMD.
<+6>: Вызов функции p(), мы увидим, как должен выглядеть стек в начале объяснений p().

-------ФУНКЦИЯ p()-------

Dump of assembler code for function p:
   0x080484d4 <+0>:     push   ebp
   0x080484d5 <+1>:     mov    ebp,esp
   0x080484d7 <+3>:     sub    esp,0x68
   0x080484da <+6>:     mov    eax,ds:0x8049860
   0x080484df <+11>:    mov    DWORD PTR [esp],eax
   0x080484e2 <+14>:    call   0x80483b0 <fflush@plt>
   0x080484e7 <+19>:    lea    eax,[ebp-0x4c]
   0x080484ea <+22>:    mov    DWORD PTR [esp],eax
   0x080484ed <+25>:    call   0x80483c0 <gets@plt>
   0x080484f2 <+30>:    mov    eax,DWORD PTR [ebp+0x4]
   0x080484f5 <+33>:    mov    DWORD PTR [ebp-0xc],eax
   0x080484f8 <+36>:    mov    eax,DWORD PTR [ebp-0xc]
   0x080484fb <+39>:    and    eax,0xb0000000
   0x08048500 <+44>:    cmp    eax,0xb0000000
   0x08048505 <+49>:    jne    0x8048527 <p+83>
   0x08048507 <+51>:    mov    eax,0x8048620
   0x0804850c <+56>:    mov    edx,DWORD PTR [ebp-0xc]
   0x0804850f <+59>:    mov    DWORD PTR [esp+0x4],edx
   0x08048513 <+63>:    mov    DWORD PTR [esp],eax
   0x08048516 <+66>:    call   0x80483a0 <printf@plt>
   0x0804851b <+71>:    mov    DWORD PTR [esp],0x1
   0x08048522 <+78>:    call   0x80483d0 <_exit@plt>
   0x08048527 <+83>:    lea    eax,[ebp-0x4c]
   0x0804852a <+86>:    mov    DWORD PTR [esp],eax
   0x0804852d <+89>:    call   0x80483f0 <puts@plt>
   0x08048532 <+94>:    lea    eax,[ebp-0x4c]
   0x08048535 <+97>:    mov    DWORD PTR [esp],eax
   0x08048538 <+100>:   call   0x80483e0 <strdup@plt>
   0x0804853d <+105>:   leave
   0x0804853e <+106>:   ret
End of assembler dump.

------ОБЪЯСНЕНИЕ-------

   0x080484d4 <+0>:     push   ebp
   0x080484d5 <+1>:     mov    ebp,esp

<+0>: Пуш ebp, чтобы сохранить начало кадра стека предыдущей функции.
<+1>: Сохраняет содержимое ESP (указатель стека), в котором содержится адрес вершины стека, в EBP.

   0x080484d7 <+3>:     sub    esp,0x68

<+3>: 104 байта выделяются основной функции для ее локальных переменных.

   0x080484da <+6>:     mov    eax,ds:0x8049860
   0x080484df <+11>:    mov    DWORD PTR [esp],eax
   0x080484e2 <+14>:    call   0x80483b0 <fflush@plt>

<+6>: обозначение "ds:[0x8049860]" означает, что мы достигаем смещения от адреса в "DS" (регистр сегмента данных), поэтому инструкция перемещает двойное слово (32-разрядное значение) из адреса "ds:[0x8049860]" в регистр eax (eax = stdout).
<+11>: Задаёт аргументы для функции fflush().
<+14>: Вызов функции fflush() со значением по адресу esp в качестве аргумента (fflush(стандартный вывод)).

   0x080484e7 <+19>:    lea    eax,[ebp-0x4c]
   0x080484ea <+22>:    mov    DWORD PTR [esp],eax
   0x080484ed <+25>:    call   0x80483c0 <gets@plt>

<+19>: Загрузка эффективного адреса ebp-0x4c в eax, поэтому eax теперь указывает на ebp-0x4c (идеально, функция gets() нуждается в указателе в качестве аргумента).
<+22>: Установка аргумента для функции gets().
<+25>: Вызов функции gets() со значением по адресу esp в качестве аргумента (получает(eax)).

   0x080484f2 <+30>:    mov    eax,DWORD PTR [ebp+0x4]
   0x080484f5 <+33>:    mov    DWORD PTR [ebp-0xc],eax
   0x080484f8 <+36>:    mov    eax,DWORD PTR [ebp-0xc]
   0x080484fb <+39>:    and    eax,0xb0000000
   0x08048500 <+44>:    cmp    eax,0xb0000000
   0x08048505 <+49>:    jne    0x8048527 <p+83>

<+30> - <+36> : Сохраните обратный адрес текущей функции в eax, а также сохраните его по адресу ebp-0xc.
<+39> - <+44> : Выполните логическое И на eax, затем сравните его с "0xb0000000". Эта проверка выполняется для того, чтобы убедиться, что мы не переписываем обратный адрес на адрес в стеке.
<+49>: JNE сравнение.  Если инструкция cmp возвращает значение true, перейдите по адресу 0x8048527 (p+83), в противном случае продолжайте.

   0x08048507 <+51>:    mov    eax,0x8048620
   0x0804850c <+56>:    mov    edx,DWORD PTR [ebp-0xc]
   0x0804850f <+59>:    mov    DWORD PTR [esp+0x4],edx
   0x08048513 <+63>:    mov    DWORD PTR [esp],eax
   0x08048516 <+66>:    call   0x80483a0 <printf@plt>

<+30> - <+36> : Сохранение обратного адреса текущей функции в eax, а также сохраненик его по адресу ebp-0xc.
<+39> - <+44> : Выполнение логическоого И на eax, затем сравнивание его с "0xb0000000". Эта проверка выполняется для того, чтобы убедиться, что мы не переписываем обратный адрес на адрес в стеке.
<+49>: JNE сравнение.  Если инструкция cmp возвращает значение true, перейдите по адресу 0x8048527 (p+83), в противном случае продолжайте.

   0x0804851b <+71>:    mov    DWORD PTR [esp],0x1
   0x08048522 <+78>:    call   0x80483d0 <_exit@plt>

<+71>: Установка аргумента для функции exit().
<+66>: Вызов функции exit() со значением по адресу esp в качестве аргумента (выход(1)).

   0x08048527 <+83>:    lea    eax,[ebp-0x4c]
   0x0804852a <+86>:    mov    DWORD PTR [esp],eax
   0x0804852d <+89>:    call   0x80483f0 <puts@plt>

<+83>: Загрузка эффективного адреса ebp-0x4c в eax, поэтому eax теперь указывает на ebp-0x4c (идеально, функция puts() нуждается в указателе в качестве аргумента).
<+86>: Установка аргумента для функции puts().
<+89>: Вызов функции puts() со значением по адресу esp в качестве аргумента (puts(ebp-0x4c)).

   0x08048532 <+94>:    lea    eax,[ebp-0x4c]
   0x08048535 <+97>:    mov    DWORD PTR [esp],eax
   0x08048538 <+100>:   call   0x80483e0 <strdup@plt>

<+94>: Загрузка эффективного адреса ebp-0x4c в eax, поэтому eax теперь указывает на ebp-0x4c (идеально, функция strdup() нуждается в указателе в качестве аргумента).
<+97>: Установка аргумента для функции strdup().
<+100>: Вызов функции strdup() со значением по адресу esp в качестве аргумента (strdup(eax)).

   0x0804853d <+105>:   leave
   0x0804853e <+106>:   ret

<+105> - <+106> : Эти две строки позволяют нам определить состояние регистров перед выполнением функции. В других терминах мы выходим из функции p().
